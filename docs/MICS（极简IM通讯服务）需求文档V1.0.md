# MICS（极简IM通讯服务）需求文档V1.0

# 1. 文档概述

## 1.1 文档目的

本文档为 MICS（Minimal IM Communication Service，极简IM通讯服务）的完整需求规范，明确项目定位、核心架构、功能需求、非功能需求、接口规范、部署要求及验收标准，作为开发、测试、部署、商用交付的唯一依据，确保所有参与方对项目需求达成一致认知。

## 1.2 项目命名

中文名称：极简IM通讯服务
英文名称：Minimal IM Communication Service
简称：MICS

## 1.3 文档范围

本文档覆盖 MICS 全生命周期需求，包括：项目定位、核心架构、SaaS多租户、集群化、多端在线、单聊/群聊、Hook外置、多语言SDK、性能、可用性、安全性、接口规范、部署运维、验收标准等，不包含外部业务系统（如存储、权限、审计）的具体实现。

## 1.4 目标受众

- 开发团队：用于技术选型、代码实现、SDK开发

- 测试团队：用于编写测试用例、执行验收测试

- 运维团队：用于部署、监控、扩缩容、故障排查

- 产品团队：用于需求复盘、版本迭代、商用对接

- 业务方：用于了解产品能力、对接方案、SDK使用

# 2. 项目定位与核心价值

## 2.1 项目定位

MICS 是一款 **SaaS化、高性能、无存储、强隔离** 的极简IM通讯底座，核心定位为「纯通讯管道」，仅负责IM基础通讯能力（连接、路由、转发），不承担任何业务数据存储、业务逻辑处理，所有存储、权限、审计、业务规则通过 Hook 机制外置，支持多租户、集群化、多端在线，适配企业级SaaS商用场景。

## 2.2 核心价值

- 极致解耦：通讯与业务完全分离，IM团队专注高性能、高可用，业务团队自主控制存储、权限、审计，迭代互不影响。

- SaaS原生：多租户强隔离，支持租户级配置、限流、Hook隔离，可直接用于公有云/私有化SaaS交付。

- 高性能：基于 .NET 10 AOT 原生编译，零GC、低延迟、高并发，单机支持10w+长连接，集群线性扩展。

- 易用性强：提供多语言SDK，业务方无需关注底层通讯细节，小时级完成接入，降低对接成本。

- 灵活扩展：无状态集群设计，支持动态扩缩容；Hook机制支持任意外部业务系统对接，适配多样化场景。

## 2.3 目标场景

- SaaS客服系统：需多租户隔离、轻量通讯、业务存储自主控制

- 企业协作IM：需高性能、多端在线、集群高可用，对接企业内部权限系统

- 社交类产品：需低延迟、高吞吐，自主控制消息存储、漫游策略

- 物联网消息推送：需长连接、低功耗、多设备接入，对接物联网平台

- 私有化部署场景：需无外部依赖、可定制化Hook对接，满足合规要求

## 2.4 竞品差异化

与主流开源IM（OpenIM、野火IM、Centrifugo）、商用云IM（腾讯云IM、网易云信）相比，MICS 的核心差异化的是：

- 比开源IM：SaaS原生多租户、AOT高性能、Hook解耦更彻底、多语言SDK更完善，商用交付更友好。

- 比商用云IM：自主可控、无 vendor 锁定，业务方可自主控制存储、数据主权，支持私有化部署。

# 3. 核心架构需求

## 3.1 架构整体原则

- 零存储原则：MICS 仅保留内存级临时状态（连接、在线路由、短期离线缓冲），不存储任何业务数据（消息、用户、群、关系链等），重启即清空。

- 多租户强隔离：全链路携带 TenantId，租户之间数据、连接、消息、资源完全隔离，无跨租户数据泄露风险。

- 无状态集群：节点无本地状态，全局状态依赖Redis，支持水平扩缩容、动态部署。

- Hook外置核心：所有业务逻辑、存储、权限、审计通过 HTTP/MQ Hook 下沉到外部系统，MICS 仅做通讯转发。

- AOT极致优化：基于 .NET 10 AOT 原生编译，禁用反射、动态代码，确保高性能、低资源占用。

## 3.2 技术栈选型（强制）

|模块分类|技术选型|核心要求|
|---|---|---|
|运行时|.NET 10 AOT|原生编译，无JIT、无反射、无动态代码，支持单文件发布|
|传输协议|ASP.NET Core WebSocket + gRPC|WebSocket 供客户端接入；gRPC（HTTP/2）供节点间通信，低延迟、高吞吐|
|序列化|Protobuf（源生成）|禁止 Newtonsoft.Json/反射序列化，强制使用源生成模式，确保AOT兼容|
|依赖注入|.NET 源生成 DI（如 Jab）|禁止运行时反射DI，强制源生成注册，降低内存占用|
|全局路由|Redis|仅存储租户在线状态（UserId→节点/设备信息），不存业务消息，支持高可用集群|
|网络IO|System.IO.Pipelines + ValueTask|零拷贝、低GC、低分配，优化长连接高并发场景性能|
|Hook体系|同步HTTP Hook + 异步MQ Hook（Kafka）|租户级隔离，支持超时、熔断、降级，确保不阻塞核心转发|
|监控日志|结构化日志 + Prometheus|日志携带TenantId/NodeId/TraceId，支持租户级监控、告警|
|部署|Docker + Kubernetes|容器化部署，支持集群扩缩容、滚动更新、故障自愈|
## 3.3 整体架构图（文字版）

MICS 整体架构分为5层，从下到上依次为：

1. 部署层：K8s集群 + Docker容器 + LB负载均衡（Nginx/Envoy），负责节点调度、负载分发、高可用保障。

2. 核心网关层（MICS Gateway）：.NET 10 AOT 部署，包含WebSocket接入、gRPC节点通信、连接管理、消息路由、租户隔离、Hook调度、短期离线缓冲等核心能力，无状态设计，支持水平扩缩容。

3. 全局状态层：Redis集群，负责存储全租户在线路由信息（UserId→NodeId/DeviceId），不存储任何业务数据。

4. Hook对接层：分为同步HTTP Hook和异步MQ Hook，负责与外部业务系统对接，传递鉴权、校验、消息事件等信息，实现业务逻辑、存储外置。

5. 接入层：多语言SDK（服务端Hook SDK + 客户端连接SDK），封装对接复杂度，为业务方、客户端提供简单易用的接入方式。

补充说明：外部业务系统（存储、权限、审计、群管理等）通过Hook对接层与MICS交互，MICS不侵入任何外部系统逻辑，仅负责通讯转发。

## 3.4 核心流程说明

### 3.4.1 客户端连接流程

1. 客户端（APP/Web/小程序）通过SDK发起WebSocket连接，携带TenantId、Token、DeviceId。

2. LB负载均衡（一致性哈希）将连接分发至MICS Gateway节点。

3. MICS Gateway调用该租户专属HTTP Hook，校验Token合法性、租户有效性，获取租户配置（Hook地址、超时、心跳等）。

4. 校验通过后，建立WebSocket长连接，记录本地连接状态，并将在线信息（TenantId:UserId→NodeId/DeviceId）写入Redis。

5. 客户端与网关建立心跳机制，维持连接保活。

### 3.4.2 单聊消息流程

1. 客户端通过SDK发送单聊消息，携带TenantId、UserId、DeviceId、ToUserId、MsgBody，经Protobuf编码后通过WebSocket发送至MICS Gateway。

2. MICS Gateway生成全局唯一MsgId，调用该租户同步HTTP Hook，校验消息合法性（权限、频率、拦截等），150ms超时熔断。

3. 路由查询与Hook校验可并行执行（保障实时性），但消息投递需以Hook校验结果为准；可提前从Redis查询ToUserId的在线节点/设备信息。

4. 若ToUserId在本节点在线：遍历其所有DeviceId，批量下发消息；若在其他节点在线：通过gRPC转发至目标节点，由目标节点下发。

5. 消息投递完成后，异步将消息事件（TenantId、MsgId、UserId、ToUserId等）投递至该租户专属MQ Topic，由外部系统消费存储。

6. 若ToUserId全不在线：将消息存入本节点内存短期缓冲（租户可配置时长，默认5分钟），待其上线后补发。

### 3.4.3 群聊消息流程

1. 客户端通过SDK发送群聊消息，携带TenantId、UserId、DeviceId、GroupId、MsgBody，经Protobuf编码后发送至MICS Gateway。

2. MICS Gateway生成全局唯一MsgId，调用该租户同步HTTP Hook，校验群合法性、用户群权限、消息频率等，150ms超时熔断。

3. 通过HTTP Hook获取该GroupId的成员列表（List<UserId>），不本地存储群成员信息。

4. 查询Redis，将群成员按在线节点拆分（本节点/其他节点），批量投递消息（本节点直接下发，其他节点gRPC转发），确保成员多端同时接收。

5. 消息投递完成后，异步将群消息事件投递至该租户专属MQ Topic，由外部系统消费存储。

6. 离线群成员：消息存入对应节点内存缓冲，上线后补发。

# 4. 功能需求

## 4.1 SaaS多租户功能（核心）

### 4.1.1 租户接入与鉴权

- 租户标识：全局唯一TenantId，所有请求、资源、消息必须携带，作为隔离核心。

- 接入鉴权：客户端连接时，MICS通过租户专属HTTP Hook校验Token合法性，返回UserId、DeviceId及租户配置，鉴权失败拒绝连接。

- 租户配置：支持租户级个性化配置，从HTTP Hook拉取，包括：Hook地址、HTTP Hook超时、MQ Topic名称、心跳超时、离线缓冲时长、限流阈值。

### 4.1.2 租户强隔离

- 数据隔离：租户之间的连接、消息、在线状态完全隔离，无跨租户数据串流、泄露。

- 资源隔离：Redis键值、MQ Topic、限流规则、Hook接口均按租户隔离，命名规范为{TenantId}:{资源标识}。

- 故障隔离：单租户Hook异常、限流触发、连接过载，不影响其他租户正常使用。

### 4.1.3 租户级限流

- 支持租户级限流配置：单租户最大连接数、单用户最大连接数（多端上限）、消息QPS上限。

- 限流触发：超过阈值时，拒绝新连接、新消息，返回明确错误码，不影响已建立连接和消息转发。

- 限流日志：触发限流时，记录结构化日志（TenantId、限流类型、阈值、当前值），支持监控告警。

## 4.2 集群化功能

### 4.2.1 无状态节点管理

- 节点无状态：所有节点对等，不存储本地业务相关状态，仅保留临时连接、离线缓冲，重启不影响全局。

- 动态扩缩容：支持K8s动态扩缩容，新增节点自动加入集群，下线节点自动清理Redis在线状态，无需人工干预。

- 节点健康检查：内置健康检查接口，K8s定期检测节点状态，故障节点自动下线、重启，实现故障自愈。

### 4.2.2 全局在线路由

- Redis存储：在线状态以{TenantId}:UserId为键，存储对应NodeId、DeviceId、Endpoint、OnlineAt等信息，支持快速查询。

- 状态同步：连接建立/关闭时，原子更新Redis在线状态；节点故障时，自动清理该节点所有在线状态。

- 路由策略：采用UserId一致性哈希，确保同一用户始终接入同一节点，降低跨节点转发开销。

### 4.2.3 节点间通信

- 通信协议：gRPC（HTTP/2，二进制），低延迟、高吞吐，AOT兼容。

- 通信场景：跨节点单聊消息转发、跨节点群聊消息批量转发。

- 连接池化：gRPC客户端连接池化，复用连接，降低连接开销，支持失败重试。

## 4.3 连接与多端在线功能

### 4.3.1 WebSocket连接管理

- 连接生命周期：支持连接建立、正常关闭、异常断开、心跳超时关闭，完整监听所有状态。

- 连接元数据：每个连接关联TenantId、UserId、DeviceId、ConnectionId、NodeId，全链路携带。

- 异常处理：连接断开时，原子清理本地连接状态和Redis在线状态，避免脏数据；支持重连机制，重连后恢复在线状态。

### 4.3.2 多端在线

- 多端支持：同一租户下，同一UserId可同时登录多个DeviceId（iOS/Android/PC/Web/小程序），支持多端同时在线。

- 消息投递：单聊/群聊消息同时投递至该UserId的所有在线DeviceId，确保多端同步接收。

- 多端状态：Redis存储该UserId的所有DeviceId在线信息，支持查询用户多端在线状态。

### 4.3.3 心跳保活

- 心跳机制：WebSocket 层可启用 Ping/Pong（链路保活）；同时定义应用层心跳帧 `ClientFrame.heartbeat_ping` / `ServerFrame.heartbeat_pong`（Protobuf binary，承载于 WebSocket Binary 帧）。由于 ASP.NET Core WebSocket API 不向应用层暴露 Ping/Pong 帧事件，心跳超时判定以应用层心跳帧/业务消息为准。

- 超时配置：心跳超时时间支持租户级配置（默认30s），在该窗口内未收到任何业务消息或 `heartbeat_ping` 则自动断开连接，清理在线状态。

- 心跳优化：心跳帧轻量化，不占用过多带宽；支持心跳频率租户级配置，适配不同客户端场景。

## 4.4 消息路由功能

### 4.4.1 单聊消息

- 消息结构：必须包含TenantId、UserId、DeviceId、ToUserId、MsgId、MsgType、MsgBody、Timestamp，Protobuf编码。

- 路由转发：支持本节点、跨节点转发，确保消息实时投递，转发延迟≤1ms（内网）。

- 离线缓冲：目标用户全不在线时，存入内存短期缓冲（租户可配置，默认5分钟），上线后自动补发；缓冲满时，按时间戳淘汰最早消息。群聊场景下离线缓冲为 best-effort，可配置上限避免大群导致内存风暴。

- 消息回执：支持消息送达回执（网关→客户端），不支持已读回执（已读逻辑外置至业务方）。

### 4.4.2 群聊消息

- 群标识：群唯一标识为{TenantId}:GroupId，不本地存储群资料、群成员。

- 成员获取：发送群消息前，通过租户HTTP Hook获取群成员列表，不缓存，确保成员实时性。

- 批量转发：支持本节点、跨节点批量转发，优化群聊扇出性能，万人群消息转发延迟≤10ms。

- 群消息过滤：不内置群消息过滤逻辑，过滤、拦截由外部HTTP Hook负责。

### 4.4.3 消息安全

- 消息去重：基于MsgId（全局唯一）去重，避免重复投递，支持幂等处理。

- 防篡改：HTTP Hook请求、MQ消息携带签名，SDK自动验签，防止消息被篡改。

- 消息加密：支持消息体加密（AES），加密密钥由业务方提供，MICS不存储、不解析加密消息内容。

## 4.5 Hook外置功能（核心）

### 4.5.1 同步HTTP Hook

作用：轻量校验、鉴权、权限判断，不阻塞核心转发，超时熔断降级。

- 必选接口：
        

    1. 租户鉴权接口：校验Token，返回UserId、DeviceId、租户配置。

    2. 消息校验接口：校验单聊/群聊消息合法性，返回允许/拒绝、备注。

    3. 群成员获取接口：根据GroupId，返回群成员List<UserId>。

- 接口规范：HTTP POST请求，Protobuf格式，携带TenantId、TraceId、RequestId、Timestamp、Sign，超时时间150ms，支持熔断、限流。

- 降级策略：HTTP Hook超时、失败时，自动降级（允许消息转发，记录日志），确保通讯不中断。

### 4.5.2 异步MQ Hook

作用：消息事件投递，由外部系统负责存储、审计、漫游，不影响MICS核心性能。

- 事件类型：连接上线事件、连接下线事件、单聊消息事件、群聊消息事件、群成员变更事件（由外部触发；MICS不维护群关系链，仅定义事件模型）。

- 投递规范：按租户分MQ Topic（如im-mics-{TenantId}-event），Protobuf编码，消息体包含完整事件信息（TenantId/EventType/MsgId/UserId/DeviceId/NodeId/TraceId...），支持持久化、重试。

- 重试机制：MQ投递失败时，存入内存重试队列（租户可配置重试次数，默认3次），指数退避重试；重试失败后，存入死信队列（DLQ），支持人工重推。

## 4.6 多语言SDK功能

### 4.6.1 SDK分类与优先级

SDK分为服务端Hook SDK和客户端连接SDK，优先实现以下语言，覆盖95%以上场景：

- 服务端Hook SDK（优先级从高到低）：Java（Spring Boot）、Go、Node.js、.NET

- 客户端连接SDK（优先级从高到低）：TypeScript（Web/H5）、Flutter（跨端APP）、微信小程序、Android（Kotlin）、iOS（Swift）

### 4.6.2 服务端Hook SDK核心能力

- 协议封装：自动解析MICS HTTP Hook请求、MQ消息，内置Protobuf序列化/反序列化，与MICS网关完全兼容。

- 安全保障：自动验签、校验TenantId、防篡改、幂等处理，降低业务方开发成本。

- 接口模板：提供标准接口抽象，业务方只需实现2~3个核心接口（鉴权、消息校验、群成员获取），即可完成对接。

- 内置组件：内置MQ消费者（Kafka）、存储适配器（MySQL/Redis/MongoDB可插拔）、熔断/超时处理、日志记录。

- 示例代码：提供完整Demo、一键运行示例，支持快速调试、接入。

### 4.6.3 客户端连接SDK核心能力

- 连接管理：封装WebSocket连接、重连、心跳、断线补偿，自动处理连接异常。

- 消息处理：封装消息发送、接收、回执、重试，Protobuf编码/加密，支持多端消息同步。

- 状态回调：提供在线状态、连接状态、消息状态回调，方便客户端界面展示。

- 轻量化：体积小、低功耗，适配移动端、小程序、Web等不同场景，无多余依赖。

- 兼容性：支持不同系统版本、浏览器版本，适配各种网络环境（4G/5G/WiFi）。

## 4.7 监控与日志功能

### 4.7.1 监控指标

- 集群指标：节点数量、在线节点数、故障节点数、扩缩容次数。

- 连接指标：全集群连接数、各租户连接数、连接建立/关闭速率、重连成功率。

- 消息指标：消息QPS、单聊/群聊消息量、跨节点转发量、离线缓冲消息量、消息转发延迟。

- Hook指标：HTTP Hook调用成功率、超时率、熔断次数；MQ投递成功率、重试次数、死信数量。

- 资源指标：各节点CPU、内存、带宽使用率，Redis命中率、QPS。

### 4.7.2 日志功能

- 结构化日志：日志格式统一为JSON，携带TenantId、NodeId、TraceId、MsgId、Time、Level、Content，支持按租户、按时间范围查询。

- 日志级别：支持DEBUG、INFO、WARN、ERROR、FATAL，可配置日志输出级别、输出路径。

- 关键日志：连接建立/关闭、消息转发失败、Hook调用失败、限流触发、节点故障等关键事件，必须记录详细日志，支持问题追溯。

### 4.7.3 告警功能

- 告警指标：支持自定义告警阈值，如CPU使用率≥80%、连接数≥阈值、Hook成功率≤95%、节点故障等。

- 告警方式：支持邮件、短信、钉钉/企业微信机器人告警，可配置告警接收人、告警频率。

# 5. 非功能需求

## 5.1 性能需求（核心）

- 连接能力：单节点支持≥10w长连接，集群支持≥100w长连接，连接建立成功率≥99.99%。

- 吞吐能力：单节点消息QPS≥1w（小消息，<1KB），集群消息QPS≥10w；群聊万人群消息转发延迟≤10ms。

- 延迟需求：单节点消息转发延迟≤1ms，跨节点消息转发延迟≤5ms（内网环境）；端到端消息延迟≤50ms（公网环境）。

- GC需求：核心链路零GC，非核心链路GC频率≤1次/分钟，GC停顿时间≤1ms。

- 资源占用：单节点（8核16G）CPU使用率≤70%（满负载），内存占用≤8G（10w连接）；单连接内存占用≤800KB。

- AOT性能：.NET 10 AOT编译后，启动时间≤1s，单文件体积≤50MB，无运行时依赖。

## 5.2 可用性需求

- 集群可用性：≥99.99%（每年故障时间≤52.56分钟），支持故障自愈，节点故障恢复时间≤30s。

- Redis可用性：≥99.99%，支持主从复制、哨兵模式，故障切换时间≤10s。

- Hook容错：HTTP Hook成功率≥99.9%，失败时自动降级；MQ投递成功率≥99.99%，重试后失败存入DLQ，不影响核心通讯。

- 灾难恢复：支持节点故障、Redis故障、机房故障的灾难恢复，恢复后不丢失在线状态、离线缓冲消息（缓冲时长内）。

## 5.3 安全性需求

- 租户隔离：严格保证租户间数据隔离，无跨租户数据泄露、串流，通过权限校验、资源隔离双重保障。

- 接口安全：HTTP Hook、SDK接口均携带签名，支持Token鉴权，防止非法调用、消息篡改。

- 数据安全：不存储任何业务数据，所有消息、事件仅做转发，不解析、不缓存敏感信息；支持消息加密传输。

- 防攻击：支持防DDOS攻击、防恶意连接、防消息轰炸，内置限流、熔断机制，抵御常见网络攻击。

- 合规性：支持日志留存（至少30天），满足企业合规、审计要求；支持私有化部署，数据不出境。

## 5.4 兼容性需求

- 客户端兼容性：
        

    - Web端：支持Chrome、Firefox、Edge等主流浏览器（最新3个版本）。

    - APP端：Android 8.0+、iOS 13.0+，Flutter 3.0+。

    - 小程序：微信小程序基础库2.20.0+。

- SDK兼容性：支持各语言最新2个稳定版本（如Java 11/17、Go 1.20/1.21、Node.js 16/18）。

- 部署兼容性：支持Linux（CentOS 8+、Ubuntu 20.04+），支持Windows；支持Docker 20.10+、K8s 1.24+。

- 协议兼容性：WebSocket RFC 6455标准，gRPC 1.50+，Protobuf 3.0+。

## 5.5 可扩展性需求

- 功能扩展：支持插件化扩展，新增功能（如超大群、消息撤回）不侵入核心代码，不影响现有功能。

- 协议扩展：Protobuf协议支持版本兼容，新增字段不影响旧版本SDK/客户端接入。

- 集群扩展：支持动态扩缩容，新增节点无需修改配置，集群容量可线性扩展。

- Hook扩展：支持新增Hook类型（如TCP Hook），不修改MICS核心代码，只需扩展Hook接口。

## 5.6 可维护性需求

- 代码规范：遵循.NET官方命名规范，模块化设计，核心代码有详细注释，便于后期维护、迭代。

- 部署维护：支持容器化部署、滚动更新、灰度发布，运维成本低；支持远程监控、故障排查。

- 日志可追溯：所有关键操作、异常事件均有日志记录，支持按TraceId、MsgId、TenantId追溯问题。

- 版本管理：支持语义化版本管理（如V1.0.0），版本升级不影响现有业务接入，支持平滑迁移。

# 6. 接口规范

## 6.1 接口概述

MICS 接口分为三类：客户端与网关接口（WebSocket）、网关与外部Hook接口（HTTP/MQ）、SDK接口（服务端/客户端），所有接口均采用Protobuf编码，确保高效、兼容。

## 6.2 客户端与网关接口（WebSocket）

### 6.2.1 连接建立接口

URL（生产建议）：wss://{gateway-domain}/ws?tenantId={TenantId}&token={Token}&deviceId={DeviceId}

说明：公网入口应强制 TLS（WSS）。内网/本地联调可使用 `ws://`（例如端口转发或直连网关 Pod）。

参数说明：

- TenantId：租户唯一标识（必填）。

- Token：客户端鉴权Token（必填）。

- DeviceId：设备唯一标识（必填，区分多端）。

返回：连接成功返回1000（正常连接）；鉴权失败返回4001（Token无效）；租户不存在返回4002（TenantId无效）。

### 6.2.2 消息发送接口（Protobuf结构）

消息类型分为单聊（SINGLE_CHAT）、群聊（GROUP_CHAT），Protobuf定义如下（简化版）：

```protobuf
syntax = "proto3";
package MICS.Message;

// 消息请求
message MessageRequest {
  string TenantId = 1;        // 租户ID（必填）
  string UserId = 2;          // 发送者ID（必填）
  string DeviceId = 3;        // 发送者设备ID（必填）
  string MsgId = 4;           // 全局唯一消息ID（必填）
  MessageType MsgType = 5;    // 消息类型（必填）
  string ToUserId = 6;        // 单聊目标用户ID（单聊必填）
  string GroupId = 7;         // 群ID（群聊必填）
  bytes MsgBody = 8;          // 消息体（必填，可加密）
  int64 Timestamp = 9;        // 发送时间戳（毫秒，必填）
}

// 消息类型
enum MessageType {
  SINGLE_CHAT = 0;            // 单聊
  GROUP_CHAT = 1;             // 群聊
}

// 消息回执
message MessageAck {
  string MsgId = 1;           // 消息ID
  AckStatus Status = 2;       // 回执状态
  int64 Timestamp = 3;        // 回执时间戳
}

// 回执状态
enum AckStatus {
  SENT = 0;                   // 已发送（网关→客户端）
  FAILED = 1;                 // 发送失败
}
```

说明（实现约束对齐）：
- WebSocket 传输采用 Protobuf binary 帧（`mics.message.v1.ClientFrame` / `ServerFrame`）。`MessageAck` 在实现中包含可选 `reason` 字段（失败原因），时间戳字段为 `timestamp_ms`。
- 消息校验：`SINGLE_CHAT` 必须提供 `ToUserId`；`GROUP_CHAT` 必须提供 `GroupId`；否则返回 `AckStatus=FAILED`，并在 `reason` 中返回原因（如 `missing to_user_id` / `missing group_id`）。
- Ack 语义：`SENT` 表示网关已接受并完成投递流程（包括：投递到在线设备或进入短期离线缓冲）；`FAILED` 表示被拒绝/未能投递（如租户 QPS 限流、`/check-message` 拒绝、群成员获取失败/为空、内部错误等）。
- 错误码：连接失败使用 WebSocket CloseCode（示例：`4001` 鉴权失败、`4002` 租户无效）；心跳超时可使用 `4100`；连接限流可使用 `4429`；Protobuf 解码失败使用 `ServerFrame.error.code=4400`。

## 6.3 网关与外部Hook接口

### 6.3.1 同步HTTP Hook接口

基础配置：HTTP POST，Content-Type: application/protobuf，超时150ms，URL：{tenant-hook-url}/{interface-name}

1. 租户鉴权接口（/auth）

- 请求体（Protobuf）：包含TenantId、Token、DeviceId。

- 响应体（Protobuf）：包含UserId、DeviceId、租户配置（Hook地址、超时、心跳等）、鉴权结果。

- 租户配置（建议字段，可按需扩展，保持 Protobuf 向后兼容：仅新增字段）：
  - 基础：HookBaseUrl、HeartbeatTimeoutSeconds、OfflineBufferTtlSeconds
  - 限流：TenantMaxConnections、UserMaxConnections、TenantMaxMessageQps
  - 安全：TenantSecret（用于 Hook 请求签名/验签）
  - Hook 隔离/容错（可选）：HookMaxConcurrency、HookQueueTimeoutMs、HookBreakerFailureThreshold、HookBreakerOpenMs、HookSignRequired

2. 消息校验接口（/check-message）

- 请求体（Protobuf）：包含MessageRequest完整信息。

- 响应体（Protobuf）：包含允许标识（true/false）、备注、拦截原因（可选）。

3. 群成员获取接口（/get-group-members）

- 请求体（Protobuf）：包含TenantId、GroupId。

- 响应体（Protobuf）：包含群成员List<UserId>、成员数量。

### 6.3.2 异步MQ Hook接口

Topic命名：im-mics-{TenantId}-event，Protobuf消息结构（简化版）：

```protobuf
syntax = "proto3";
package MICS.Hook;

// MQ事件消息
message MqEvent {
  string TenantId = 1;        // 租户ID（必填）
  EventType EventType = 2;    // 事件类型（必填）
  string MsgId = 3;           // 消息ID（消息事件必填）
  string UserId = 4;          // 操作用户ID（必填）
  string DeviceId = 5;        // 操作设备ID（必填）
  string ToUserId = 6;        // 单聊目标用户ID（单聊事件必填）
  string GroupId = 7;         // 群ID（群聊事件必填）
  bytes EventData = 8;        // 事件详细数据（必填）
  int64 Timestamp = 9;        // 事件时间戳（必填）
  string NodeId = 10;         // 网关节点ID（必填）
}

// 事件类型
enum EventType {
  CONNECT_ONLINE = 0;         // 连接上线
  CONNECT_OFFLINE = 1;        // 连接下线
  SINGLE_CHAT_MSG = 2;        // 单聊消息
  GROUP_CHAT_MSG = 3;         // 群聊消息
}
```

说明：
- 本仓库实现以 `src/Mics.Contracts/Protos/mics_hook.proto` 中的 `mics.hook.v1.MqEvent` / `EventType` 为准（字段保持兼容：仅新增）。
- `event_data` 为 Protobuf bytes，默认投递：
  - 连接事件：`mics.message.v1.ConnectAck` 序列化 bytes
  - 消息事件：`mics.message.v1.MessageRequest` 序列化 bytes

## 6.4 SDK接口规范

SDK接口采用抽象化设计，各语言接口名称、参数一致，仅语法适配对应语言，详细接口文档随SDK发布，包含：

- 服务端Hook SDK：鉴权接口、消息校验接口、群成员获取接口、MQ消息消费接口等。

- 客户端连接SDK：连接接口、消息发送接口、消息接收接口、心跳接口、重连接口、状态回调接口等。

# 7. 部署与运维需求

## 7.1 部署环境需求

### 7.1.1 硬件环境（单节点）

- CPU：≥8核（Intel Xeon E5/V5 或同等性能），支持AVX2指令集（AOT优化）。

- 内存：≥16G（推荐32G，支持更多连接）。

- 磁盘：≥100G SSD（用于存储日志、容器镜像）。

- 网络：千兆网卡（内网），公网带宽根据并发连接数配置（推荐≥100M）。

### 7.1.2 软件环境

- 操作系统：Linux（CentOS 8+、Ubuntu 20.04+），64位，关闭SELinux。

- 容器环境：Docker 20.10+、Kubernetes 1.24+。

- Redis：6.2+，集群模式（主从复制+哨兵），内存≥16G。

- MQ：Kafka 3.0+，集群模式，至少3个节点。

- 负载均衡：Nginx 1.21+ 或 Envoy 1.20+，支持WebSocket长连接保持。

## 7.2 部署架构

- 集群部署：基于K8s集群部署，MICS Gateway节点、Redis节点、Kafka节点均分布式部署，确保高可用。

- 网络架构：客户端通过公网/LB接入MICS Gateway，节点间、Gateway与Redis/Kafka通过内网通信，隔离公网风险。

- 存储架构：日志存储采用ELK栈（Elasticsearch+Logstash+Kibana），支持日志检索、分析；监控数据存储采用Prometheus，可视化采用Grafana。

## 7.3 运维需求

- 部署自动化：支持Docker镜像构建、K8s部署脚本，实现一键部署、滚动更新、灰度发布。

- 监控运维：内置监控指标，集成Prometheus+Grafana，支持自定义监控面板、告警配置；支持远程故障排查、日志查询。

- 扩缩容运维：支持K8s HPA自动扩缩容（根据CPU、连接数触发），也支持手动扩缩容，扩缩容过程不影响业务。

- 故障运维：节点故障自动下线、重启；Redis/Kafka故障自动切换；提供故障排查手册，支持快速定位、解决问题。

- 版本升级：支持平滑升级，升级过程不中断连接、不丢失消息；支持版本回滚，确保升级失败可快速恢复。

# 8. 验收标准

## 8.1 功能验收

- SaaS多租户：租户接入鉴权正常，租户间数据隔离，限流功能生效，租户配置拉取、隔离机制符合需求；单个租户故障不影响其他租户，限流触发时返回正确错误码并记录日志。

- 集群化功能：节点无状态部署正常，动态扩缩容无需人工干预，新增节点自动加入集群、下线节点自动清理Redis在线状态；节点间gRPC通信正常，跨节点消息转发无丢失、无延迟。

- 连接与多端在线：WebSocket连接建立/断开/重连正常，心跳保活机制生效，心跳超时自动断开连接；同一用户多端在线时，消息可同步投递至所有在线设备，多端状态查询准确。

- 消息路由：单聊/群聊消息转发准确，无丢失、无重复、无篡改；离线缓冲功能生效，目标用户上线后可正常补发消息；消息去重、加密（如需）功能符合要求，消息回执正常。

- Hook外置：同步HTTP Hook（鉴权、消息校验、群成员获取）调用正常，超时、失败时可自动降级；异步MQ Hook事件投递准确，重试机制生效，失败消息可存入死信队列，支持人工重推。

- 多语言SDK：优先实现的SDK（服务端4种、客户端4种）可正常接入，接口调用流畅，协议封装、验签、序列化功能正常；SDK示例代码可一键运行，能快速完成对接调试。

- 监控与日志：监控指标（集群、连接、消息、Hook、资源）可正常采集，可视化面板展示清晰；结构化日志输出规范，关键事件（连接异常、消息失败、Hook异常等）可追溯，日志查询、筛选正常；告警功能生效，触发阈值后可正常推送告警信息。

## 8.2 非功能验收

- 性能验收：单节点支持≥10w长连接，集群≥100w长连接，连接建立成功率≥99.99%；单节点消息QPS≥1w，集群≥10w，万人群消息转发延迟≤10ms；单节点消息转发延迟≤1ms，跨节点≤5ms，公网端到端≤50ms；核心链路零GC，非核心链路GC频率≤1次/分钟、停顿≤1ms；单节点（8核16G）满负载CPU≤70%、内存≤8G，单连接内存≤800KB；.NET 10 AOT编译后启动≤1s，单文件体积≤50MB。

- 可用性验收：集群可用性≥99.99%，节点故障恢复时间≤30s；Redis可用性≥99.99%，故障切换时间≤10s；HTTP Hook调用成功率≥99.9%，MQ投递成功率≥99.99%，Hook失败/超时可正常降级，不影响核心通讯；灾难恢复后，在线状态、缓冲时长内的离线消息不丢失。

- 安全性验收：租户间数据完全隔离，无跨租户数据串流、泄露；HTTP Hook、SDK接口鉴权、验签正常，可有效防止非法调用、消息篡改；支持消息加密传输（如需），不存储、不解析敏感业务数据；可抵御DDOS、恶意连接、消息轰炸等常见攻击，限流、熔断机制生效；日志留存≥30天，私有化部署可满足数据合规要求。

- 兼容性验收：客户端（Web/APP/小程序）兼容对应版本要求，无连接、消息接收异常；SDK兼容对应语言最新2个稳定版本，接口调用无异常；部署环境兼容指定Linux版本、Docker、K8s、Redis、Kafka版本，无部署失败、运行异常；WebSocket、gRPC、Protobuf协议兼容对应标准，无协议不兼容问题。

- 可扩展性验收：支持插件化扩展新增功能，不侵入核心代码；Protobuf协议新增字段后，旧版本SDK/客户端可正常接入；集群可动态扩缩容，新增节点无需修改配置；可扩展新增Hook类型，不修改MICS核心代码。

- 可维护性验收：代码符合.NET官方命名规范，核心代码有详细注释；支持容器化部署、滚动更新、灰度发布，运维操作便捷；关键操作、异常事件日志可追溯，支持按TraceId、MsgId、TenantId查询；版本升级平滑，不影响现有业务，支持版本回滚。

## 8.3 接口验收

- 客户端与网关接口：WebSocket连接建立、消息发送/接收、回执功能正常；连接参数错误（无效TenantId、Token）时，返回正确错误码；消息Protobuf编码/解码正常，无乱码、解析失败问题。

- Hook接口：同步HTTP Hook三个必选接口（鉴权、消息校验、群成员获取）调用正常，参数传递准确，响应符合规范，超时、熔断机制生效；异步MQ Hook事件投递准确，Topic命名符合规范，Protobuf消息结构正确，重试、死信队列功能正常。

- SDK接口：服务端/客户端SDK接口调用正常，无异常报错；接口参数、返回值符合规范，与MICS网关、Hook接口兼容；SDK内置的验签、序列化、连接管理等功能正常生效。

## 8.4 部署运维验收

- 部署验收：可基于Docker+K8s正常部署，部署脚本可一键执行；MICS Gateway、Redis、Kafka、LB负载均衡可正常联动，无部署失败、服务无法启动问题；符合指定的硬件、软件环境要求。

- 监控运维验收：Prometheus+Grafana监控可正常采集指标，自定义监控面板、告警配置可正常生效；日志可通过ELK栈正常检索、分析；支持远程故障排查、日志查询。

- 扩缩容验收：支持K8s HPA自动扩缩容，可根据CPU、连接数触发扩缩容；手动扩缩容操作便捷，扩缩容过程中不中断现有连接、不丢失消息。

- 故障与版本验收：节点、Redis、Kafka故障时可自动切换、自愈；版本升级可平滑进行，升级后功能正常；支持版本回滚，回滚后可恢复至升级前状态，无数据丢失、功能异常。

## 8.5 验收结论

1.  验收通过：所有验收项（功能、非功能、接口、部署运维）均满足本文档需求，无重大缺陷，轻微缺陷可在规定时间内整改完成，视为验收通过。

2.  验收不通过：存在重大缺陷（如租户隔离失效、消息大面积丢失、集群无法正常运行、核心接口调用失败等），或关键验收项未满足需求，视为验收不通过，需整改后重新提交验收。

3.  验收备注：验收过程中需留存验收记录、测试报告、故障排查日志等相关资料，作为验收依据；验收通过后，本文档将作为MICS项目开发、交付、运维的最终依据，后续版本迭代需基于本文档进行需求更新及验收调整。
> （注：文档部分内容可能由 AI 生成）
