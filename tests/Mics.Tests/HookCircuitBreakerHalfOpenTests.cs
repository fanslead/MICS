using System.Net;
using System.Net.Http;
using Google.Protobuf;
using Microsoft.Extensions.Logging.Abstractions;
using Mics.Contracts.Hook.V1;
using Mics.Contracts.Message.V1;
using Mics.Gateway.Hook;
using Mics.Gateway.Metrics;

namespace Mics.Tests;

public sealed class HookCircuitBreakerHalfOpenTests
{
    private sealed class ManualTimeProvider : TimeProvider
    {
        private DateTimeOffset _now;

        public ManualTimeProvider(DateTimeOffset now)
        {
            _now = now;
        }

        public override DateTimeOffset GetUtcNow() => _now;

        public void Advance(TimeSpan delta) => _now = _now.Add(delta);
    }

    private sealed class NoSecrets : IAuthHookSecretProvider
    {
        public bool TryGet(string tenantId, out string secret)
        {
            secret = "";
            return false;
        }
    }

    private sealed class FixedMetaFactory : IHookMetaFactory
    {
        public HookMeta Create(string tenantId) => new HookMeta { TenantId = tenantId, RequestId = "r1", TimestampMs = 1, Sign = "" };
    }

    private sealed class OkHandler : HttpMessageHandler
    {
        protected override Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)
        {
            var resp = new HttpResponseMessage(HttpStatusCode.OK)
            {
                Content = new ByteArrayContent(new AuthResponse { Ok = true, UserId = "u1", DeviceId = "d1", Config = new TenantRuntimeConfig { HookBaseUrl = "http://hook" } }.ToByteArray()),
            };
            resp.Content.Headers.ContentType = new System.Net.Http.Headers.MediaTypeHeaderValue("application/protobuf");
            return Task.FromResult(resp);
        }
    }

    [Fact]
    public async Task HalfOpenAttempt_ThatNeverCallsHook_DoesNotWedgeBreaker()
    {
        const string tenantId = "t1";

        var time = new ManualTimeProvider(DateTimeOffset.UnixEpoch);
        var breaker = new HookCircuitBreaker(time);
        var metrics = new MetricsRegistry();

        var defaults = new HookPolicyDefaults(
            MaxConcurrencyDefault: 1,
            TenantMaxConcurrencyFallback: new Dictionary<string, int>(),
            QueueTimeoutDefault: TimeSpan.Zero,
            BreakerFailureThresholdDefault: 1,
            BreakerOpenDurationDefault: TimeSpan.FromSeconds(1),
            SignRequiredDefault: false);

        var policies = new TenantHookPolicyCache(defaults);
        var limiter = new HookConcurrencyLimiter(metrics);

        var http = new HttpClient(new OkHandler())
        {
            Timeout = Timeout.InfiniteTimeSpan,
        };

        var client = new HookClient(
            http,
            timeout: TimeSpan.FromMilliseconds(50),
            breaker: breaker,
            metaFactory: new FixedMetaFactory(),
            authSecrets: new NoSecrets(),
            policies: policies,
            concurrencyLimiter: limiter,
            metrics: metrics,
            logger: NullLogger<HookClient>.Instance,
            timeProvider: time);

        var policy = policies.Get(tenantId);
        breaker.OnFailure(tenantId, HookOperation.CheckMessage, policy.Breaker);

        time.Advance(TimeSpan.FromSeconds(2)); // move past open duration -> half-open

        var hold = await limiter.TryAcquireAsync(tenantId, HookOperation.CheckMessage, policy.Acquire, CancellationToken.None);
        Assert.NotNull(hold);

        var cfg = new TenantRuntimeConfig { HookBaseUrl = "http://hook", TenantSecret = "" };
        var msg = new MessageRequest
        {
            TenantId = tenantId,
            UserId = "u1",
            DeviceId = "d1",
            MsgId = "m1",
            MsgType = MessageType.SingleChat,
            ToUserId = "u2",
            MsgBody = ByteString.CopyFrom(new byte[] { 1 }),
            TimestampMs = 1,
        };

        var result = await client.CheckMessageAsync(cfg, tenantId, msg, CancellationToken.None);
        Assert.True(result.Allow);
        Assert.True(result.Degraded);
        Assert.Equal("hook queue rejected", result.Reason);

        // If the half-open slot isn't released, TryBegin will return false here and the breaker is wedged.
        Assert.True(breaker.TryBegin(tenantId, HookOperation.CheckMessage));

        await hold!.DisposeAsync();
    }
}

